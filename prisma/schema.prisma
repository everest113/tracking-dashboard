generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model scanned_conversations {
  id              Int       @id @default(autoincrement())
  conversation_id String    @unique @db.VarChar(255)
  subject         String?
  shipments_found Int       @default(0)
  scanned_at      DateTime  @default(now())
  last_message_at DateTime?

  @@index([conversation_id], map: "idx_conversation_id")
}

model shipments {
  id                    Int                   @id @default(autoincrement())
  po_number             String?               @db.VarChar(255)
  tracking_number       String                @unique @db.VarChar(255)
  carrier               String?               @db.VarChar(100)
  status                String                @default("pending") @db.VarChar(50)
  origin                String?
  destination           String?
  shipped_date          DateTime?
  estimated_delivery    DateTime?
  delivered_date        DateTime?
  last_checked          DateTime?
  created_at            DateTime              @default(now())
  updated_at            DateTime
  supplier              String?               @db.VarChar(255)
  front_conversation_id String?               @db.VarChar(255)
  ship24_tracker_id     String?               @unique @db.VarChar(255)
  last_error            String?
  ship24_status         String?               @db.VarChar(100)
  ship24_last_update    DateTime?
  tracking_events       tracking_events[]
  // Note: OMG data is now joined by po_number, not by relation

  @@index([front_conversation_id], map: "idx_front_conversation")
  @@index([po_number], map: "idx_po_number")
  @@index([status], map: "idx_status")
  @@index([ship24_tracker_id], map: "idx_ship24_tracker")
}

// OMG Orders data - separate from shipments to avoid polluting the shipment model
model omg_purchase_orders {
  id             Int       @id @default(autoincrement())
  shipment_id    Int?      // Nullable - kept for backwards compat but not used for joins
  po_number      String    @unique @db.VarChar(50) // Normalized format (e.g., "189-1") - used for joining

  // OMG identifiers
  order_number   String    @db.VarChar(50) // Human-readable order number (e.g., "164")
  omg_order_id   String    @db.VarChar(50) // MongoDB ObjectID for URLs
  omg_po_id      String    @db.VarChar(50) // MongoDB ObjectID for URLs

  // Denormalized order data
  order_name     String?   @db.VarChar(255) // e.g., "Sample Order"
  customer_name  String?   @db.VarChar(255)
  customer_email String?   @db.VarChar(255) // Primary email for Front thread matching

  // Recipients as JSONB array
  recipients     Json?     @default("[]") // Array of { name, address, city, state, zip, country }

  // Sync metadata
  synced_at      DateTime  @default(now())
  raw_data       Json?     // Full OMG response for debugging

  // Note: shipment_id kept for backwards compat but join is now by po_number

  @@unique([omg_po_id]) // Each OMG PO should only appear once
  @@index([po_number], map: "idx_omg_po_number")
  @@index([order_number], map: "idx_omg_order_number")
  @@index([customer_email], map: "idx_omg_customer_email")
}

model sync_history {
  id                             Int       @id @default(autoincrement())
  conversations_processed        Int       @default(0)
  conversations_already_scanned  Int       @default(0)
  shipments_added                Int       @default(0)
  shipments_skipped              Int       @default(0)
  conversations_with_no_tracking Int       @default(0)
  batch_size                     Int       @default(10)
  limit                          Int       @default(100)
  duration_ms                    Int?
  errors                         String[]  @default([])
  status                         String    @default("success") @db.VarChar(50)
  started_at                     DateTime  @default(now())
  completed_at                   DateTime?
  source                         String    @default("manual") @db.VarChar(50)

  @@index([started_at], map: "idx_started_at")
  @@index([source], map: "idx_source")
}

model tracking_events {
  id          Int       @id @default(autoincrement())
  shipment_id Int
  status      String?   @db.VarChar(50)
  location    String?
  message     String?
  event_time  DateTime?
  created_at  DateTime  @default(now())
  shipments   shipments @relation(fields: [shipment_id], references: [id], onDelete: Cascade)

  @@index([shipment_id], map: "idx_shipment_id")
}

model event_queue {
  id           String      @id @default(cuid())
  topic        String
  payload      Json
  status       EventStatus @default(PENDING)
  attempts     Int         @default(0)
  max_attempts Int?        @default(5)
  dedupe_key   String?     @unique
  available_at DateTime    @default(now())
  locked_at    DateTime?
  created_at   DateTime    @default(now())
  updated_at   DateTime    @updatedAt
  last_error   String?
}

model event_consumer_offsets {
  id         Int      @id @default(autoincrement())
  consumer   String
  topic      String
  last_id    String?
  created_at DateTime @default(now())
  updated_at DateTime @updatedAt

  @@unique([consumer, topic])
}

enum EventStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
}

// =============================================================================
// AUDIT HISTORY
// Generic append-only audit log for tracking actions on any entity.
// Follows W3C Activity Streams concepts: actor performs action on entity.
// =============================================================================

model audit_history {
  id          String   @id @default(cuid())
  
  // Polymorphic entity reference
  entity_type String   @db.VarChar(50)   // 'shipment', 'order', 'customer_thread', etc.
  entity_id   String   @db.VarChar(100)  // The ID of the entity
  
  // Action metadata
  action      String   @db.VarChar(100)  // 'tracking_email_sent', 'thread_matched', 'status_changed', etc.
  actor       String   @default("system") @db.VarChar(100)  // 'system', 'user:123', 'cron:update-tracking'
  
  // Flexible payload for action-specific data
  metadata    Json     @default("{}")
  
  // Outcome
  status      String   @db.VarChar(50)   // 'success', 'failed', 'skipped'
  error       String?                     // Error message if failed
  
  created_at  DateTime @default(now())
  
  // Indexes for common query patterns
  @@index([entity_type, entity_id], map: "idx_audit_entity")
  @@index([action], map: "idx_audit_action")
  @@index([created_at(sort: Desc)], map: "idx_audit_created")
  @@index([entity_type, action], map: "idx_audit_type_action")
}
