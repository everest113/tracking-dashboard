generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model scanned_conversations {
  id              Int       @id @default(autoincrement())
  conversation_id String    @unique @db.VarChar(255)
  subject         String?
  shipments_found Int       @default(0)
  scanned_at      DateTime  @default(now())
  last_message_at DateTime? // Timestamp of the most recent message in the conversation

  @@index([conversation_id], map: "idx_conversation_id")
}

model shipments {
  id                    Int               @id @default(autoincrement())
  po_number             String?           @db.VarChar(255)
  tracking_number       String            @unique @db.VarChar(255)
  carrier               String?           @db.VarChar(100)
  status                String            @default("pending") @db.VarChar(50)
  origin                String?
  destination           String?
  shipped_date          DateTime?         // Date shipped (from extraction or Ship24)
  estimated_delivery    DateTime?         // Expected delivery from Ship24
  delivered_date        DateTime?         // Actual delivery date from Ship24
  last_checked          DateTime?
  created_at            DateTime          @default(now())
  updated_at            DateTime
  supplier              String?           @db.VarChar(255)
  front_conversation_id String?           @db.VarChar(255)
  ship24_tracker_id     String?           @unique @db.VarChar(255)
  ship24_status         String?           @db.VarChar(100)  // Detailed Ship24 status
  ship24_last_update    DateTime?         // Last update from Ship24
  last_error            String?           // Last error (for debugging)
  tracking_events       tracking_events[]

  @@index([front_conversation_id], map: "idx_front_conversation")
  @@index([po_number], map: "idx_po_number")
  @@index([status], map: "idx_status")
  @@index([ship24_tracker_id], map: "idx_ship24_tracker")
}

model sync_history {
  id                             Int       @id @default(autoincrement())
  source                         String    @default("manual") @db.VarChar(50)  // "manual" or "automatic"
  conversations_processed        Int       @default(0)
  conversations_already_scanned  Int       @default(0)
  shipments_added                Int       @default(0)
  shipments_skipped              Int       @default(0)
  conversations_with_no_tracking Int       @default(0)
  batch_size                     Int       @default(10)
  limit                          Int       @default(100)
  duration_ms                    Int?
  errors                         String[]  @default([])
  status                         String    @default("success") @db.VarChar(50)
  started_at                     DateTime  @default(now())
  completed_at                   DateTime?

  @@index([started_at], map: "idx_started_at")
  @@index([source], map: "idx_source")
}

model tracking_events {
  id          Int       @id @default(autoincrement())
  shipment_id Int
  status      String?   @db.VarChar(50)
  location    String?
  message     String?
  event_time  DateTime?
  created_at  DateTime  @default(now())
  shipments   shipments @relation(fields: [shipment_id], references: [id], onDelete: Cascade)

  @@index([shipment_id], map: "idx_shipment_id")
}

model event_queue {
  id           String      @id @default(cuid())
  topic        String
  payload      Json
  status       EventStatus @default(PENDING)
  attempts     Int         @default(0)
  max_attempts Int?        @default(5)
  dedupe_key   String?     @unique
  available_at DateTime    @default(now())
  locked_at    DateTime?
  created_at   DateTime    @default(now())
  updated_at   DateTime    @updatedAt
  last_error   String?
}

model event_consumer_offsets {
  id         Int      @id @default(autoincrement())
  consumer   String
  topic      String
  last_id    String?
  created_at DateTime @default(now())
  updated_at DateTime @updatedAt

  @@unique([consumer, topic])
}

enum EventStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
}
