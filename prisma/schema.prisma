generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model scanned_conversations {
  id              Int       @id @default(autoincrement())
  conversation_id String    @unique @db.VarChar(255)
  subject         String?
  shipments_found Int       @default(0)
  scanned_at      DateTime  @default(now())
  last_message_at DateTime?

  @@index([conversation_id], map: "idx_conversation_id")
}

model shipments {
  id                    Int                   @id @default(autoincrement())
  po_number             String?               @db.VarChar(255)
  tracking_number       String                @unique @db.VarChar(255)
  carrier               String?               @db.VarChar(100)
  status                String                @default("pending") @db.VarChar(50)
  origin                String?
  destination           String?
  shipped_date          DateTime?
  estimated_delivery    DateTime?
  delivered_date        DateTime?
  last_checked          DateTime?
  created_at            DateTime              @default(now())
  updated_at            DateTime
  supplier              String?               @db.VarChar(255)
  front_conversation_id String?               @db.VarChar(255)
  ship24_tracker_id     String?               @unique @db.VarChar(255)
  last_error            String?
  ship24_status         String?               @db.VarChar(100)
  ship24_last_update    DateTime?
  tracking_events       tracking_events[]
  omg_purchase_order    omg_purchase_orders?

  @@index([front_conversation_id], map: "idx_front_conversation")
  @@index([po_number], map: "idx_po_number")
  @@index([status], map: "idx_status")
  @@index([ship24_tracker_id], map: "idx_ship24_tracker")
}

// OMG Orders data - separate from shipments to avoid polluting the shipment model
model omg_purchase_orders {
  id             Int       @id @default(autoincrement())
  shipment_id    Int?      @unique // Nullable - PO may exist before shipment arrives
  po_number      String    @db.VarChar(50) // Normalized format (e.g., "189-1")

  // OMG identifiers
  omg_order_id   Int       // OMG's numeric order ID
  omg_order_uuid String    @db.VarChar(36) // UUID for URLs
  omg_po_id      Int       @unique // OMG's numeric PO ID (unique constraint)
  omg_po_uuid    String    @db.VarChar(36) // UUID for URLs

  // Denormalized order data
  order_name     String?   @db.VarChar(255) // e.g., "Sample Order"
  customer_name  String?   @db.VarChar(255)

  // Recipients as JSONB array
  recipients     Json?     @default("[]") // Array of { name, address, city, state, zip, country }

  // Sync metadata
  synced_at      DateTime  @default(now())
  raw_data       Json?     // Full OMG response for debugging

  // Relations
  shipment       shipments? @relation(fields: [shipment_id], references: [id], onDelete: SetNull)

  @@index([po_number], map: "idx_omg_po_number")
  @@index([omg_order_id], map: "idx_omg_order_id")
}

model sync_history {
  id                             Int       @id @default(autoincrement())
  conversations_processed        Int       @default(0)
  conversations_already_scanned  Int       @default(0)
  shipments_added                Int       @default(0)
  shipments_skipped              Int       @default(0)
  conversations_with_no_tracking Int       @default(0)
  batch_size                     Int       @default(10)
  limit                          Int       @default(100)
  duration_ms                    Int?
  errors                         String[]  @default([])
  status                         String    @default("success") @db.VarChar(50)
  started_at                     DateTime  @default(now())
  completed_at                   DateTime?
  source                         String    @default("manual") @db.VarChar(50)

  @@index([started_at], map: "idx_started_at")
  @@index([source], map: "idx_source")
}

model tracking_events {
  id          Int       @id @default(autoincrement())
  shipment_id Int
  status      String?   @db.VarChar(50)
  location    String?
  message     String?
  event_time  DateTime?
  created_at  DateTime  @default(now())
  shipments   shipments @relation(fields: [shipment_id], references: [id], onDelete: Cascade)

  @@index([shipment_id], map: "idx_shipment_id")
}

model event_queue {
  id           String      @id @default(cuid())
  topic        String
  payload      Json
  status       EventStatus @default(PENDING)
  attempts     Int         @default(0)
  max_attempts Int?        @default(5)
  dedupe_key   String?     @unique
  available_at DateTime    @default(now())
  locked_at    DateTime?
  created_at   DateTime    @default(now())
  updated_at   DateTime    @updatedAt
  last_error   String?
}

model event_consumer_offsets {
  id         Int      @id @default(autoincrement())
  consumer   String
  topic      String
  last_id    String?
  created_at DateTime @default(now())
  updated_at DateTime @updatedAt

  @@unique([consumer, topic])
}

enum EventStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
}
