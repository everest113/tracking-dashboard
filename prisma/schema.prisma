generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model scanned_conversations {
  id              Int       @id @default(autoincrement())
  conversation_id String    @unique @db.VarChar(255)
  subject         String?
  shipments_found Int       @default(0)
  scanned_at      DateTime  @default(now())
  last_message_at DateTime? // Timestamp of the most recent message in the conversation

  @@index([conversation_id], map: "idx_conversation_id")
}

model shipments {
  id                    Int               @id @default(autoincrement())
  po_number             String?           @db.VarChar(255)
  tracking_number       String            @unique @db.VarChar(255)
  carrier               String?           @db.VarChar(100)
  status                String            @default("pending") @db.VarChar(50)
  origin                String?
  destination           String?
  shipped_date          DateTime?         // Date shipped (from extraction or Ship24)
  estimated_delivery    DateTime?         // Expected delivery from Ship24
  delivered_date        DateTime?         // Actual delivery date from Ship24
  last_checked          DateTime?
  created_at            DateTime          @default(now())
  updated_at            DateTime
  supplier              String?           @db.VarChar(255)
  front_conversation_id String?           @db.VarChar(255)
  ship24_tracker_id     String?           @unique @db.VarChar(255)
  ship24_status         String?           @db.VarChar(100)  // Detailed Ship24 status
  ship24_last_update    DateTime?         // Last update from Ship24
  last_error            String?           // Last error (for debugging)
  tracking_events       tracking_events[]

  @@index([front_conversation_id], map: "idx_front_conversation")
  @@index([po_number], map: "idx_po_number")
  @@index([status], map: "idx_status")
  @@index([ship24_tracker_id], map: "idx_ship24_tracker")
}

model sync_history {
  id                             Int       @id @default(autoincrement())
  source                         String    @default("manual") @db.VarChar(50)  // "manual" or "automatic"
  conversations_processed        Int       @default(0)
  conversations_already_scanned  Int       @default(0)
  shipments_added                Int       @default(0)
  shipments_skipped              Int       @default(0)
  conversations_with_no_tracking Int       @default(0)
  batch_size                     Int       @default(10)
  limit                          Int       @default(100)
  duration_ms                    Int?
  errors                         String[]  @default([])
  status                         String    @default("success") @db.VarChar(50)
  started_at                     DateTime  @default(now())
  completed_at                   DateTime?

  @@index([started_at], map: "idx_started_at")
  @@index([source], map: "idx_source")
}

model tracking_events {
  id          Int       @id @default(autoincrement())
  shipment_id Int
  status      String?   @db.VarChar(50)
  location    String?
  message     String?
  event_time  DateTime?
  created_at  DateTime  @default(now())
  shipments   shipments @relation(fields: [shipment_id], references: [id], onDelete: Cascade)

  @@index([shipment_id], map: "idx_shipment_id")
}

model event_queue {
  id           String      @id @default(cuid())
  topic        String
  payload      Json
  status       EventStatus @default(PENDING)
  attempts     Int         @default(0)
  max_attempts Int?        @default(5)
  dedupe_key   String?     @unique
  available_at DateTime    @default(now())
  locked_at    DateTime?
  created_at   DateTime    @default(now())
  updated_at   DateTime    @updatedAt
  last_error   String?
}

model event_consumer_offsets {
  id         Int      @id @default(autoincrement())
  consumer   String
  topic      String
  last_id    String?
  created_at DateTime @default(now())
  updated_at DateTime @updatedAt

  @@unique([consumer, topic])
}

enum EventStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
}

// ============================================================================
// Notification System
// ============================================================================

enum NotificationChannel {
  EMAIL
  SLACK
  WEBHOOK
  SMS
}

enum NotificationStatus {
  PENDING
  PROCESSING
  SENT
  FAILED
}

model notification_templates {
  id          String              @id @default(cuid())
  name        String              @unique
  channel     NotificationChannel
  subject     String?             // For email
  body        String              // Template body (Handlebars syntax)
  metadata    Json?               // Channel-specific metadata (e.g., Slack block kit)
  enabled     Boolean             @default(true)
  created_at  DateTime            @default(now())
  updated_at  DateTime            @updatedAt

  rules       notification_rules[]
}

model notification_rules {
  id            String              @id @default(cuid())
  name          String
  description   String?
  trigger_event String              // e.g., "shipment.delivered", "shipment.exception"
  filter        Json?               // Optional JSONPath/predicate to filter events
  template_id   String
  enabled       Boolean             @default(true)
  created_at    DateTime            @default(now())
  updated_at    DateTime            @updatedAt

  template      notification_templates @relation(fields: [template_id], references: [id], onDelete: Cascade)
  recipients    notification_recipients[]

  @@index([trigger_event])
  @@index([enabled])
}

model notification_recipients {
  id         String              @id @default(cuid())
  rule_id    String
  channel    NotificationChannel
  target     String              // Email address, Slack channel ID, webhook URL, phone number
  metadata   Json?               // Additional recipient-specific data
  created_at DateTime            @default(now())
  updated_at DateTime            @updatedAt

  rule       notification_rules  @relation(fields: [rule_id], references: [id], onDelete: Cascade)

  @@index([rule_id])
}

model notification_queue {
  id           String             @id @default(cuid())
  rule_id      String?
  event_id     String?            // Reference to source event_queue.id
  channel      NotificationChannel
  recipient    String             // Target address/channel
  subject      String?
  body         String
  metadata     Json?              // Rendered payload, attachments, etc.
  status       NotificationStatus @default(PENDING)
  attempts     Int                @default(0)
  max_attempts Int                @default(5)
  available_at DateTime           @default(now())
  locked_at    DateTime?
  sent_at      DateTime?
  last_error   String?
  created_at   DateTime           @default(now())
  updated_at   DateTime           @updatedAt

  @@index([channel, status])
  @@index([available_at])
}

model notification_log {
  id           String              @id @default(cuid())
  queue_id     String?             // Reference to notification_queue.id
  channel      NotificationChannel
  recipient    String
  subject      String?
  body         String
  status       NotificationStatus
  provider_id  String?             // External provider message ID (e.g., SES message ID)
  metadata     Json?
  sent_at      DateTime            @default(now())

  @@index([channel])
  @@index([sent_at])
  @@index([recipient])
}
